<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="../../_static/favicon_16x16.png" sizes="16x11" rel="icon" type="image/png">
    <link href="../../_static/favicon_32x32.png" sizes="32x21" rel="icon" type="image/png">
    <title>Architecture Design Record - Event Throtteling &#8212; elos  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Design Decisions - Enforce usage of _FORTIFY_SOURCE" href="usage_of_FORTIFY_SOURCE.html" />
    <link rel="prev" title="Architecture Design Record - Event Storage Class" href="event_storage_class.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="architecture-design-record-event-throtteling">
<h1>Architecture Design Record - Event Throtteling<a class="headerlink" href="#architecture-design-record-event-throtteling" title="Permalink to this heading">¶</a></h1>
<section id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Permalink to this heading">¶</a></h2>
<p>Elos is built do receive and distribute Events from many different
sources (e.g. Scanners and Clients) to many different sinks (e.g.
Clients, Backends). This can result in rather severe problems if one of
the source starts generating thousands of Events in a very short
timespan. This could be either a malicous Program or simply a
malfunctioning component like a Kernel driver that suddenly starts
dumping trace-dumps in an endless loop.</p>
<p>How can we ensure that Elos continues to operate safely under such
conditions?</p>
</section>
<section id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Improve the design to let it operate as safely as possible while
under duress</p></li>
<li><p>Detect attacks or malfunctioning components</p></li>
<li><p>Create countermeasures, like closing a connection or shutting a
scanner down</p></li>
<li><p>Make sure that important Events are still processed as quickly as
possible</p></li>
</ul>
</section>
<section id="excluded">
<h2>Excluded<a class="headerlink" href="#excluded" title="Permalink to this heading">¶</a></h2>
<p>Operating system and/or Kernel level countermeasures. These can be
neccessary for certain sources, like Events coming over TCP/IP
connections - These are out of scope of this ADR and have to be
considered separately.</p>
</section>
<section id="considerations">
<h2>Considerations<a class="headerlink" href="#considerations" title="Permalink to this heading">¶</a></h2>
<p>There are several different ways of overwhelming Elos, which shall be
viewed here before coming to a final conclusion.</p>
<section id="connection-flooding">
<h3>Connection flooding<a class="headerlink" href="#connection-flooding" title="Permalink to this heading">¶</a></h3>
<p>Connection flooding (e.g. trying to create thousands of connections in a
short timespan) needs to be viewed and considered separately for each
connecting type (e.g. Unix, TCP/IP), as there can be big differences
there - Especially in available means to detect malicious connection
attempts, which in turn would allow us to drop or ignore certain
connections.</p>
<p>The simplest and most universal countermeasure is to limit the amount of
connections by a configuration parameter. This comes with problem
though: While the limit keeps <code class="docutils literal notranslate"><span class="pre">elosd</span></code>, and by extension, the embedded
system behind it from being overwhelmed, any Client trying to connect to
<code class="docutils literal notranslate"><span class="pre">elosd</span></code> won’t be able to do so as long as the attackers maxed out
connections are still open, preventing any further communication.</p>
<p>Another attack scenario might be counting the maximum amount of
connections by connecting to <code class="docutils literal notranslate"><span class="pre">elosd</span></code> until it fails, then keep closing
and opening connections as fast as possible with the counted maximum as
a limit.</p>
<p>The simplest countermeasure here would be to add a timestamp as a
component and disable the interface completely for a certain time, if
the amount of opened/closed connections in a timeframe is too high -
Which unfortunately has the same problem as the generic connection
limit.</p>
<p><em>Any further mitigations are highly connection type dependend and need</em>
<em>to be viewed separetely each, which is out of scope of this document.</em></p>
</section>
<section id="subscription-flooding">
<h3>Subscription flooding<a class="headerlink" href="#subscription-flooding" title="Permalink to this heading">¶</a></h3>
<p>Subscription flooding can be caused by e.g. a Client generating
thousands of subscriptions in a very short amount of time. Sadly there
is no sane and safe way of detecting malicious subscriptions, as even
the most simple form, checking for duplicated filters, is time consuming
and very easily defeated by randomizing the filter rules during
subscription.</p>
<ul class="simple">
<li><p>The only way to defend against this is to limit the amount of
subscriptions a client can do via a configuration parameter.</p></li>
</ul>
</section>
<section id="data-flooding">
<h3>Data flooding<a class="headerlink" href="#data-flooding" title="Permalink to this heading">¶</a></h3>
<p>Data flooding means to publish Events with a payload of several
Gigabytes, which can easily overwhelm a target in terms of processing
power, memory bandwidth and memory capacity while it tries to parse and
convert the enormous amount of data. Especially the latter is the most
dangerous here, as it forces a system to swap or trigger its
Out-Of-Memory emergency handling, which very rarely goes well for its
performance and general stability.</p>
<p>Unfortunately there is no sane and safe way to properly detect if a
payload is filled with gargabe or sensible data.</p>
<ul class="simple">
<li><p>The only way to defend against this type of attack is to limit the
incoming size of the Event by a configuration parameter and drop such
Events at the receiving stage before memory allocation and processing
occurs.</p></li>
<li><p>Additional checks need to be considered, as even Events with a size
limit can still overwhelm the memory capacity easily if enough of
them are created.</p></li>
</ul>
</section>
<section id="data-stalling">
<h3>Data stalling<a class="headerlink" href="#data-stalling" title="Permalink to this heading">¶</a></h3>
<p>Data stalling is the process of interrupting an ongoing communication by
not answering a data packet, or only answering it partially by, for
example, only sending the header but not the body of the message.</p>
<p>The only way to mitigate this issue is to make sure any connection
related code can’t be stalled by adding timeouts where neccessary.</p>
</section>
<section id="event-flooding">
<h3>Event flooding<a class="headerlink" href="#event-flooding" title="Permalink to this heading">¶</a></h3>
<p>Event flooding can be caused by malicious intent or malfunctioning
components, generating a huge number of Events in very short timespans.
Like with the subscriptions, there is no sane and safe way of detecting
which Events are bad and which are not.</p>
<ul class="simple">
<li><p>This problem can be migitated by introducing a ringbuffer for each
source that has a configureable set of limitations that can be
checked against when Events are written into it. This also gives us
an effective way to deal with misbehavig components, e.g. we can
react and forcible close a Client connection in case it violates too
many of the imposed limits.</p></li>
</ul>
</section>
<section id="event-throtteling-prioritizing">
<h3>Event throtteling/prioritizing<a class="headerlink" href="#event-throtteling-prioritizing" title="Permalink to this heading">¶</a></h3>
<p>We need to make sure that important Events are processed and passed on
quickly, even if we have DDoS attacks like described above going on.</p>
<ul class="simple">
<li><p>To make this work we need to start splitting and decoupling some of
the inner workings of the EventProcessor to allow processing of
Events in multiple threads, which will also include priotization of
certain Events.</p></li>
</ul>
</section>
<section id="event-merging">
<h3>Event merging<a class="headerlink" href="#event-merging" title="Permalink to this heading">¶</a></h3>
<p>Sometimes even a well functioning component can generate many messages
with the same content. Ideally we can detect and merge such Events into
a singular entry. This comes with its own set of problems however in
terms of how and what we can compare, e.g. a small variable part like a
timestamp within the payload would make this a big hassle to implement.
We also strongly need to consider performance here, as operations like
these can very quickly get very expensive.</p>
<p><em>This is out of scope of this document and needs to be carefully
considered</em> <em>with a couple of different scenarios (e.g.
Syslog/Kmsg/…).</em></p>
</section>
</section>
<section id="design-1">
<h2>Design 1<a class="headerlink" href="#design-1" title="Permalink to this heading">¶</a></h2>
<p>The Design shall focus on the changes neccessary to mitigate the attack
scenarios above. It is important to note that this design iteratively
co-evolved with the considerations mentioned above, meaning that the
considerations expanded each time an earlier “Design 1” or potential
“Design 2” ran into problems and vice-versa. Due to this a “Design 2”
that also solves all the considerations does not exist at the time.</p>
<section id="connection-flooding-1">
<span id="id1"></span><h3>Connection flooding<a class="headerlink" href="#connection-flooding-1" title="Permalink to this heading">¶</a></h3>
<p><em>As mentioned above, connection type specific countermeasures are out of
scope</em> <em>of this document, so only the basic countermeasures are handled
here.</em></p>
<p>The first connection flooding scenario, opening as much connections as
possible, already has a basic mitigation in place, with the
ClientManager having a maximum connection limit defined by
<code class="docutils literal notranslate"><span class="pre">CLIENT_MANAGER_MAX_CONNECTIONS</span></code>.</p>
<p>This implementation can be sligthly improved by moving this define into
the configuration files. The suggested value is:
<code class="docutils literal notranslate"><span class="pre">elos/ClientManager/Limits/MaximumConnections/{integer}</span></code></p>
<p>The second scenario, closing and opening as many connections as
possible, currently has no countermeasures implemented. The easiest way
to defend against this is to introduce a <code class="docutils literal notranslate"><span class="pre">NewConnectionsPerSecond</span></code>
Limit that is checked each time a new connection is made and stops to
listen for new connections for a specified amount of time, while also
generating an appropriate Event to be logged. The primary goal here is
to keep <code class="docutils literal notranslate"><span class="pre">elosd</span></code> operative as well as keeping it from consuming too
much processing power on the embedded system - Losing the ability to
connect to <code class="docutils literal notranslate"><span class="pre">elosd</span></code> for this time is unfortunate but by far the lesser
evil compared to everything else stalling on the target; Already
established connections will be unaffected by this.</p>
<p>The implementation shall use two configuration values
<code class="docutils literal notranslate"><span class="pre">NewConnectionsPerSecond</span></code> and <code class="docutils literal notranslate"><span class="pre">ConnectionFloodingTimeout</span></code>, these
must be put in the same configuration space as <code class="docutils literal notranslate"><span class="pre">MaximumConnections</span></code>.
The listen loop that waits for new connections needs to be extended by
the mentioned connections-per-second counter. In case the limit is
reached, an appropriate Event shall be published, followed by a simple
wait command (e.g. <code class="docutils literal notranslate"><span class="pre">nanosleep()</span></code>) that waits for the defined time,
after which normal operation continues.</p>
</section>
<section id="subscription-flooding-1">
<span id="id2"></span><h3>Subscription flooding<a class="headerlink" href="#subscription-flooding-1" title="Permalink to this heading">¶</a></h3>
<p>Currently the amounts of subscriptions a client can create is not
restricted. This can be solved in a very similar fashion to connection
flooding by adding a value to the configuration file. The value can then
checked every time <code class="docutils literal notranslate"><span class="pre">elosMessageEventSubscribe</span></code> is called by comparing
it against the amount of EventQueues associated with the connection.
Should the limit be reached, and error string shall be returned to the
client describing the problem.</p>
<p>Suggested configuration value:
<code class="docutils literal notranslate"><span class="pre">elos/ClientManager/Limits/MaximumSubscriptionsPerConnection/{integer}</span></code>
Suggested error string:
<code class="docutils literal notranslate"><span class="pre">&quot;maximum</span> <span class="pre">amount</span> <span class="pre">of</span> <span class="pre">subscriptions</span> <span class="pre">per</span> <span class="pre">connection</span> <span class="pre">reached&quot;</span></code></p>
</section>
<section id="data-flooding-1">
<span id="id3"></span><h3>Data flooding<a class="headerlink" href="#data-flooding-1" title="Permalink to this heading">¶</a></h3>
<p>Currently the amounts of data a client can send is not restricted. This
can be solved in the same way as with Connection/Subscription flooding
by checking against a configuration value while receiving messages. The
value is ideally buffered in one of the shared data structeres to make
access faster, as the read function is called very often. The suggested
value is: <code class="docutils literal notranslate"><span class="pre">elos/ClientManager/Limits/MaximumDataLength/{integer}</span></code></p>
</section>
<section id="data-stalling-1">
<span id="id4"></span><h3>Data stalling<a class="headerlink" href="#data-stalling-1" title="Permalink to this heading">¶</a></h3>
<p>There is currently no protection against data stalling. To solve this we
need to extend our reading and writing functions with a timeout as well
as new return codes so we can properly identify and propagate the
timeout error.</p>
<p>The timeout value needs to be based on a configuration value, which
ideally is buffered for performance reasons. The suggest configuration
value is:
<code class="docutils literal notranslate"><span class="pre">elos/ClientManager/Limits/DataSendReceiveTimeout/{sec,nsec}</span></code></p>
</section>
<section id="event-flooding-and-event-throtteling-prioritizing">
<h3>Event flooding and Event throtteling/prioritizing<a class="headerlink" href="#event-flooding-and-event-throtteling-prioritizing" title="Permalink to this heading">¶</a></h3>
<p><em>Event flooding and Event throtteling/prioritizing are viewed together
here;</em> <em>These can’t be solved independendly, as every change made for
one will affect</em> <em>the other with the way we implement the solution.</em></p>
<p>The current implementation has the EventProcessor as a singular instance
when it comes to processing Events; All sources share this instance with
a single set of filters (as well as mutexes), so it is currently
relatively easy to stall it by overwhelming it with dozens of
Subscriptions or too many Events at once.</p>
<p>This shall be solved by, as mentioned above, restructing the
EventProcessor. as well as adding two new components that will help with
handling the scenarios mentioned above.</p>
<p>The new data path will roughly be as the following:
<code class="docutils literal notranslate"><span class="pre">Source</span> <span class="pre">-&gt;</span> <span class="pre">Publish</span> <span class="pre">-&gt;</span> <span class="pre">EventBuffer</span> <span class="pre">-&gt;</span> <span class="pre">EventDispatcher</span> <span class="pre">-&gt;</span> <span class="pre">EventProcessorPipeline</span> <span class="pre">-&gt;</span> <span class="pre">Sink</span></code></p>
<p>Every source (e.g. Scanner or a Client) will receive its own EventBuffer
which it can write into with Publish. A Pipeline will essentially be
what the EventProcessor currently is, a set of filters with their
respective sinks (e.g. Client, Backends, Scanner). The difference here
is that we will be able to configure and run many Pipelines in parallel,
this includes fixed Pipelines for our Backends as well as dynamic ones
created for Client subscriptions. These Pipelines shall be able to be
grouped into several threads (1..n Pipelines per thread). The
EventDispatcher will run 1..n threads that are resonsible to safely
distribute the Events within the EventBuffers to the various Pipelines,
with the focus on processing the more important Events as soon as
possible.</p>
<p><strong>Attention</strong>: As these are a lot of rather complex changes we shall try
to break this overhaul down into as simple as possible chunks that are
easier to implement and that can be extended with the intended feature
set later. Based on this we’re going to focus on EventBuffer and the
EventDispatcher first, with the EventProcessor following once the first
two are established.</p>
<section id="eventbuffer">
<h4>EventBuffer<a class="headerlink" href="#eventbuffer" title="Permalink to this heading">¶</a></h4>
<p>The EventBuffer is the new publish point for Events in Clients and
Scanners. Its primary purpose is to give each Source its own RingBuffer
that can be filled without affecting any other Source, thus helping with
detecting and defending against Event flooding style attacks. Its
secondary purpose is to help with Event throtteling/prioritizing by
pre-sorting Events in a way that minimizes the work the EventDispatcher
has do to - Ideally the EventDispatcher does not need to parse the
Events in any form and can focus on dispatching the available Events by
simply copying them to the different Pipelines as fast as possible.</p>
<p>Handling of these buffers shall be invisible to both and has to be
handled by e.g. the ClientManager and the ScannerManager. Since
read/write speed is extremely important here we won’t have a centralized
component managing these Buffers, as we do not want to do an id based
lookup every time we publish an event - Instead the EventBuffer shall be
a standalone component.</p>
<p>The EventBuffer is intended to have 1..n RingBuffers based on the
Event’s priority, configured with parameters during the EventBuffers
creation. There up to two ways on how to define this priority: The
Event’s <code class="docutils literal notranslate"><span class="pre">.severity</span></code> field (extremely fast to check) and by defining
1..n EventFilters, which is extremely powerful, but could be too slow
depending on how many Events are processed per second.</p>
<p><em>Due to the current lack of EventFilter performance data and the
aforementioned</em> <em>focus on getting the components established first, the
priority handling will</em> <em>be fleshed out in more detail once the new
infrastructure is established</em> <em>(after which it will be easy to add and
test new features).</em></p>
<p>The intial implementation shall be based on the following:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Data types</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">elosId_t</span><span class="w"> </span><span class="n">elosEventBufferId_t</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elosEventBuffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elosFlag_t</span><span class="w">          </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">elosEventBufferId_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_mutex_t</span><span class="w">     </span><span class="n">mutex</span><span class="p">;</span>
<span class="w">    </span><span class="n">safuVec_t</span><span class="w">           </span><span class="o">*</span><span class="n">eventVec</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">            </span><span class="n">eventVecPos</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">            </span><span class="n">limitEventCount</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// More to follow, e.g. time limit, callbacks, priority based buffers</span>
<span class="p">}</span><span class="w"> </span><span class="n">elosEventBuffer_t</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elosEventBufferParam</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elosEventBufferId_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">            </span><span class="n">limitEventCount</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">elosEventBufferParam_t</span><span class="p">;</span>

<span class="c1">// Functions</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferNew</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">**</span><span class="n">eventBuffer</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferInitialize</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">elosEventBufferParam_t</span><span class="w"> </span><span class="n">param</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferRead</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">safuVec_t</span><span class="w"> </span><span class="o">**</span><span class="n">eventVec</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferWrite</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">elosEvent_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferDeleteMembers</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventBufferDelete</span><span class="p">(</span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Notes</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Read</span></code> shall, for now, detach the <code class="docutils literal notranslate"><span class="pre">eventVec</span></code> (much like
EventQueue) and create a new one during read.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Write</span></code> shall write the given Event into <code class="docutils literal notranslate"><span class="pre">eventVec</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eventVec</span></code> needs to behave like a RingBuffer, <code class="docutils literal notranslate"><span class="pre">limitEventCount</span></code>
and <code class="docutils literal notranslate"><span class="pre">eventVecPos</span></code> should be used to implement the behaviour. This
may be moved into its own component in the future.</p></li>
</ul>
</section>
<section id="eventdispatcher">
<h4>EventDispatcher<a class="headerlink" href="#eventdispatcher" title="Permalink to this heading">¶</a></h4>
<p>The main problem with giving each Source its own EventBuffer is how we
get many Events in different EventQueues to multiple
EventProcessorPipelines while keeping everything coherent - How do we
know if all the Pipelines finished reading from a given EventBuffer for
example? What if one of the Pipelines is really slow or hangs for some
reason? To circumvent these problems the EventDispatcher is added.</p>
<p>The EventDispatcher’s main purpose is to copy Events from EventBuffers
to the various EventProcessorPipelines as quickly as possible. Is is
intended to be able to configure multiple EventDispatchers with
different priorities, with a central EventDispatcherManager that is
responsible for setting up (and cleaning up) everything.</p>
<p>Each EventDispatcher will run in its own thread and distributes the
contents (based on priority) from 1..n EventBuffers to 1..n
EventProcessorPipelines. Later on it is intended to be able to group
several Dispatchers into a single thread, but for the beginning every
Dispatcher will run in its own thread.</p>
<p>The initial implementation shall be based around the following:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Data types</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elosEventDispatcher</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elosFlag_t</span><span class="w">           </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_mutex_t</span><span class="w">      </span><span class="n">mutex</span><span class="p">;</span>
<span class="w">    </span><span class="n">safuVec_t</span><span class="w">            </span><span class="n">eventBufferPtrVec</span><span class="p">;</span>
<span class="w">    </span><span class="n">samconfConfig_t</span><span class="w">      </span><span class="o">*</span><span class="n">config</span><span class="p">;</span>
<span class="w">    </span><span class="n">elosEventProcessor_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventProcessor</span><span class="p">;</span>
<span class="w">    </span><span class="n">elosEventBufferId_t</span><span class="w">  </span><span class="n">idCount</span><span class="p">;</span><span class="w"> </span><span class="c1">// To be replaced later with idManager</span>
<span class="p">}</span><span class="w"> </span><span class="n">elosEventDispatcher_t</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elosEventDispatcherParam</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">samconfConfig_t</span><span class="w">      </span><span class="o">*</span><span class="n">config</span><span class="p">;</span>
<span class="w">    </span><span class="n">elosEventProcessor_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventProcessor</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">elosEventDispatcherParam_t</span><span class="p">;</span>

<span class="c1">// Functions</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherNew</span><span class="p">(</span><span class="n">elosEventDispatcher_t</span><span class="w"> </span><span class="o">**</span><span class="n">eventDispatcher</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherInitialize</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">,</span><span class="w"> </span><span class="n">elosEventDispatcherParam_t</span><span class="w"> </span><span class="n">param</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherBufferAdd</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">,</span><span class="w"> </span><span class="n">elosEventBuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">elosEventBufferId_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventBufferId</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherBufferRemove</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">,</span><span class="w"> </span><span class="n">elosEventBufferId_t</span><span class="w"> </span><span class="n">eventBufferId</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherDispatch</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherStart</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherStop</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherDeleteMembers</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">);</span>
<span class="n">safuResultE_t</span><span class="w"> </span><span class="nf">elosEventDispatcherDelete</span><span class="p">(</span><span class="n">elosEventVector_t</span><span class="w"> </span><span class="o">*</span><span class="n">eventDispatcher</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Notes</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BufferAdd</span></code> and <code class="docutils literal notranslate"><span class="pre">BufferRemove</span></code> shall be used by e.g. the
ClientManager and the ScannerManager to add and remove Buffers that
the <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> uses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Start</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code> are responsible for handling the background
thread that runs the EventDispatcher.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dispatch</span></code> is intended to be used internally by the background
thread only, it shall read from all Buffers in <code class="docutils literal notranslate"><span class="pre">eventBufferPtrVec</span></code>
and forward them to the <code class="docutils literal notranslate"><span class="pre">EventProcessor</span></code>.</p></li>
<li><p>The EventDispatcherManager will use nearly the same set of functions
and parameters as EventDispatcher, due to this the code snippets for
it are not present here.</p></li>
<li><p>The initial implementation will simply read from 1..n Buffers and
pass them on directly to the current EventProcessor to get things
running.</p></li>
</ul>
</section>
<section id="eventprocessorpipeline">
<h4>EventProcessorPipeline<a class="headerlink" href="#eventprocessorpipeline" title="Permalink to this heading">¶</a></h4>
<p>The EventProcessor will be reworked to have multiple configureable
Pipelines, with, as mentioned above, each Pipeline having a similiar
featureset compared to what the EventProcessor currently has.</p>
<p>It is intended that 1..n Pipelines run in a thread, with each Pipeline
having their own EventBuffer that is filled by EventDispatchers. Each
Pipeline will also have 1..n EventFilters as well as 1 “Sink” (e.g. a
EventQueue or a Backend), to which the Events will be passed in case one
of the EventFilters matches.</p>
<p>The details to this component will be fleshed out in more detail once
the basic EventBuffers and EventDispatchers are established in the
codebase.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/elos_blue.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">elos</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../UserManual.html">Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demo.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">elos API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="adrs.html">Architecture Design Records</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="atomic_variables.html">Architecture Design Record - Atomic Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="elos-coredump.html">Architecture Design Record - Detecting Coredumps</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_authorization.html">Architecture Design Record - Event publishing authorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_authorization_blacklisting.html">Architecture Design Record - Blacklist filtering of published events</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_logging_storage_concept.html">Architecture Design Record - Event Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_retention_policies.html">Architecture Design Record - Event Retention Policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_storage_backends.html">Architecture Design Record - Event Storage Backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_storage_backends.html#decision-1">Decision</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_storage_class.html">Architecture Design Record - Event Storage Class</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Architecture Design Record - Event Throtteling</a></li>
<li class="toctree-l2"><a class="reference internal" href="usage_of_FORTIFY_SOURCE.html">Design Decisions - Enforce usage of _FORTIFY_SOURCE</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="adrs.html">Architecture Design Records</a><ul>
      <li>Previous: <a href="event_storage_class.html" title="previous chapter">Architecture Design Record - Event Storage Class</a></li>
      <li>Next: <a href="usage_of_FORTIFY_SOURCE.html" title="next chapter">Design Decisions - Enforce usage of _FORTIFY_SOURCE</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, wolfgang.gehrhardt@emlix.com.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/generated/ADRs/event_throtteling.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>