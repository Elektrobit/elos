<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="../../_static/favicon_16x16.png" sizes="16x11" rel="icon" type="image/png">
    <link href="../../_static/favicon_32x32.png" sizes="32x21" rel="icon" type="image/png">
    <title>Architecture Design Record - Event publishing authorization &#8212; elos  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Architecture Design Record - Blacklist filtering of published events" href="event_authorization_blacklisting.html" />
    <link rel="prev" title="Architecture Design Record - Evaluation Of Logging Frameworks" href="elos_logging_frameworks.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="architecture-design-record-event-publishing-authorization">
<h1>Architecture Design Record - Event publishing authorization<a class="headerlink" href="#architecture-design-record-event-publishing-authorization" title="Link to this heading">¶</a></h1>
<section id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Link to this heading">¶</a></h2>
<p>Elos is designed to publish events from elos-clients or scanner-plugins to
interested subscribers. How to ensure only authorized client can publish
certain events?</p>
</section>
<section id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>avoid exploitation of the event logging system to trigger certain system
behavior by unprivileged access.</p>
<ul>
<li><p>i.e. Provides a wrong system view by injecting events</p></li>
</ul>
</li>
<li><p>trace and/or detect possible intrusion</p></li>
</ul>
</section>
<section id="assumptions">
<h2>Assumptions<a class="headerlink" href="#assumptions" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Tcp/Ip is required as API-Interface</p></li>
<li><p>Unix Domain Sockets are possible as further API-Interface (i.e. earlier
available as Tcp/Ip when it comes to booting things up)</p></li>
<li><p>remote access to elosd API is required in future</p></li>
<li><p>a third party authentication instance is possible, identity service</p></li>
<li><p>incoming events via internal scanner-plugin-API are treated as trust-able.</p>
<ul>
<li><p>Rationale: scanners are loaded as <code class="docutils literal notranslate"><span class="pre">*.so</span></code> files into the elosd process.
Hence they have full access to any data of the process and further
protection is pointless.</p></li>
</ul>
</li>
</ul>
</section>
<section id="excluded">
<h2>Excluded<a class="headerlink" href="#excluded" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>How to ensure only authorized subscribers can subscribe to certain events?</p></li>
</ol>
<ul class="simple">
<li><p>This ADR does not cover handling of sensitive data that need a
confidentiality protection (i.e. keys in coredumps, syslog entries with
security sensitive data). This aspect is left to another ADR.</p></li>
<li><p>in this ADR we assume that any one can read every event</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Transport Layer Security</p></li>
</ol>
<ul class="simple">
<li><p>communication can be plain text</p></li>
<li><p>this ADR consider no efforts in encryption of communication channels</p></li>
<li><p>no authentication of subscribers</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Remote event transfer</p></li>
</ol>
<ul class="simple">
<li><p>in this ADR it is assumed that elos handles only local events. No event is
crossing the network wires. This would be part of another ADR.</p></li>
</ul>
</section>
<section id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Link to this heading">¶</a></h2>
<p>For elos we divide the publishing clients in “privileged” and “normal” clients.
Each event has a classification field which can be used by the integrator to mark critical
events. ( Hint: The idea is to mark critical events as such by the publisher and expect
the subscriber to subscribe or at least to check for the appropriate
classification flags in an event.)
Elosd gets configured to blacklist all events matching a certain event filter
to drop all attempts of publishing events marked as critical from an non secured
channel.</p>
<p>So if a client tries to publish a critical message elos will only dispatch it
if the channel is secured. Subscribers can rely on the fact that events with
security classification flags are only published from privileged and authorized
clients.</p>
<section id="privileged-client">
<h3>Privileged Client<a class="headerlink" href="#privileged-client" title="Link to this heading">¶</a></h3>
<p>Privileged client must be authorized and hence needs some authentication. To
permit publishing of black listed events a client must be authorized and
therefore the communication is treated as secured.</p>
<p>On a secured communication it is allowed to send any event, no blackList will be applied.
In a later development stage it could be allowed to send only configured events. This
could be done by RPN-filter rules per client like AccessControlList for events.</p>
<p>To assume a secured communication a client must be authenticated. Currently the
following three approaches are thinkable:
A) Trusted channel: authenticate the local client process connected via
UnixDomain socket / localhost tcp/ip ( only system local)
B) Certificate: authentication via public private keys (allow remote systems)
C) Token: A third party (identification service) takes over the authentication
and authorization (allow remote systems)</p>
<section id="trusted-channel">
<h4>Trusted channel<a class="headerlink" href="#trusted-channel" title="Link to this heading">¶</a></h4>
<p>Trusted channel is the working title for a authentication / authorization
method, that tries to identify the connecting process. This approach only works
on local system as it assumes integrity of the channel and reliable detection of endpoints.
The goal is to gather the following set of information about the connecting process:</p>
<ul class="simple">
<li><p>UID -&gt; effective user id of the connecting client</p></li>
<li><p>GID -&gt; effective group id of the connecting client</p></li>
<li><p>PID -&gt; current process id of the connecting client</p>
<ul>
<li><p>determined at runtime during connecting and is necessary to identify the process in procfs</p></li>
<li><p>with <code class="docutils literal notranslate"><span class="pre">/proc/${PID}/*</span></code> -&gt; many additional information about the connecting
process which can be used to authorize the connecting process. In example
the  name of the process or the link to the original executable file.</p></li>
</ul>
</li>
</ul>
<p>The method to obtain the necessary process information differs for the two
considered interface types Tcp/IP and Unix domain sockets.</p>
<section id="unix-sockets">
<h5>Unix-sockets<a class="headerlink" href="#unix-sockets" title="Link to this heading">¶</a></h5>
<p>For STREAM Unix socket bound to a path name we can use the following options for authorization:</p>
<ul class="simple">
<li><p>The Linux sock_diag module via netlink API to query UID,GID and PID. With the
<code class="docutils literal notranslate"><span class="pre">getsockopt</span></code> call this can be simplified to <code class="docutils literal notranslate"><span class="pre">getsockopt(clientSocket,</span> <span class="pre">SOCK_STREAM,</span> <span class="pre">SO_PEERCRED,</span> <span class="pre">&amp;creds,</span> <span class="pre">&amp;creds_length);</span></code>.</p>
<ul>
<li><p>Unfortunately this is very Linux specific, but until nothing other is
specified we can use it by enabling <code class="docutils literal notranslate"><span class="pre">_GNU_SOURCE</span></code> for this part.</p></li>
<li><p>The Unix socket must be bound to a path, for unnamed or abstract Unix
socket this setup will probably not work.</p></li>
</ul>
</li>
</ul>
</section>
<section id="local-tcp-ip-loopback-interface">
<h5>local Tcp/ip (loopback interface)<a class="headerlink" href="#local-tcp-ip-loopback-interface" title="Link to this heading">¶</a></h5>
<p>To authorize local Tcp/Ip connections we need also to identify the connecting process.</p>
<p>This requires:</p>
<ul class="simple">
<li><p>root privileges for elos or a process to make the actual lookup for elos</p></li>
<li><p>The peer address must be bound to a local interface (127.0.0.1) , in a later
stage also the public interface could be allowed if necessary</p></li>
</ul>
<p>The actual process lookup is can be done by either calling <code class="docutils literal notranslate"><span class="pre">netstat</span></code> or <code class="docutils literal notranslate"><span class="pre">ss</span></code> or
any equivalent tool. But preferably the kernel interface used by tools like
<code class="docutils literal notranslate"><span class="pre">netstat</span></code> shall be used directly. See therefore <code class="docutils literal notranslate"><span class="pre">/proc/net</span></code> and <code class="docutils literal notranslate"><span class="pre">sock_diag</span></code>.</p>
</section>
<section id="final-step">
<h5>Final step<a class="headerlink" href="#final-step" title="Link to this heading">¶</a></h5>
<p>Now it is possible to match the process information against a set of rule set defined in the configuration:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;trustedProcesses&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;&lt;client name | identifier&gt;&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;gid&quot;</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;executable&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/bin/crinit&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Or by reuseing RPN-Filter:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;trustedProcesses&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;&lt;nameOfExecutable&gt;&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="s2">&quot;.uid 0 EQ .exec &#39;/bin/crinit&#39; STRCMP AND&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;.uid 0 EQ .gid 0 EQ AND&quot;</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and decide if the client can be treated as privileged.</p>
</section>
<section id="conclusion">
<h5>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h5>
<p><em>pro:</em></p>
<ul class="simple">
<li><p>Can be done without changing the protocol or adding any overhead to it
<em>cons:</em></p></li>
<li><p>the lookup could be time consuming</p>
<ul>
<li><p>Rational: but usually only one lookup per connection should be feasable</p></li>
</ul>
</li>
<li><p>works only for local processes</p></li>
</ul>
</section>
</section>
<section id="authorization-via-certificates">
<h4>authorization via certificates<a class="headerlink" href="#authorization-via-certificates" title="Link to this heading">¶</a></h4>
<p>To authorize a connecting client it shall be sufficient to know that the client
can prove its identity. This can be done by using certificates.
Common certificate based socket communication protocols focuses on the tcp/ip
interface, but it shall be possible to use them also via unix domain sockets.</p>
<p>The authorized entity is the process which have access to the certificate and
key. Thus a successful handshake and established  secure connection proves that the
client is authorized to publish classified events. Certificates usually
authenticate a certain domain name, this can be used to distinguish between
different clients.
The configuration for cetificate based authorization would be based on domain
names and could look like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;trustedProcesses&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;com.emlix.asecureapp&quot;</span><span class="p">:{</span>
<span class="w">    </span><span class="nt">&quot;cert&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/etc/elos/client_certs/asecureapp.crt&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;com.elektrobit.an.evenmore.secureapp&quot;</span><span class="p">:{</span>
<span class="w">    </span><span class="nt">&quot;cert&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/etc/elos/client_certs/amoresecureapp.crt&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="how-to-authorize-a-publisher">
<h5>how to authorize a publisher<a class="headerlink" href="#how-to-authorize-a-publisher" title="Link to this heading">¶</a></h5>
<p>Usualy certificate based authorization comes with encrypted connections and a special connection.
This requires a second socket, where elos expects to create a
secured connection. The process of authorization shall be as follows:</p>
<ol class="arabic simple">
<li><p>client connect to secure Tcp/Ip or Unix socket i.e 128.0.0.1:5432 instead of 127.0.0.1:54321 or /run/elosd.<strong>s</strong>sock instead of /run/elosd.sock</p></li>
<li><p>elosd accepts incoming connection and initiate handshake (https://wiki.openssl.org/index.php/Simple_TLS_Server)
3a. if successful flag connection as secured and trustable and if needed store domain name
3b. if unsuccessful drop the connection and issue an appropriate event</p></li>
<li><p>start communication as usual but be sure to use ssl_read/ssl_write methods</p></li>
<li><p>continue until connection is closed</p></li>
</ol>
</section>
<section id="summary">
<h5>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h5>
<p><em>pro:</em></p>
<ul class="simple">
<li><p>with TLS this uses commonly used technology, proven in use</p></li>
<li><p>less complicated to implement and to prove security then secure channel approach</p></li>
<li><p>allows to authenticate and authorize remote clients</p></li>
</ul>
<p><em>cons:</em></p>
<ul class="simple">
<li><p>needs two sockets (secure and unsecure)</p></li>
<li><p>needs rework of current connection handling in elos</p></li>
<li><p>due to the encryption a overhead can be expected in for event publishing as for connecting to elosd</p></li>
<li><p>probably increased start time due to loading of certificates</p></li>
<li><p>needs certificate and private key infrastructure.</p>
<ul>
<li><p>How to issue them</p></li>
<li><p>How to revoke them</p></li>
<li><p>How to deploy them</p></li>
<li><p>How to store keys securely</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="authorization-via-token">
<h4>authorization via token<a class="headerlink" href="#authorization-via-token" title="Link to this heading">¶</a></h4>
<p>Regardless of the actual choosen implementation of a token based authorization
it would work the following way. The token based approach extends the elos
protocol by an additional field containg a token, which was created by a third
party service. The client previously proves its authentiy against some identity
service and got the token in exchange. The identity service and elosd shares
some common secret. This way elosd can decode the token and verify the client
has authorized itself on some identification service.</p>
<p>The token can contain additonal information see JWT (JSON WebToken JWT.io) for example.</p>
<p>Elosd needs to manage at least one key to verify the tokens.
A configuration could look like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;eventAuthKey&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/path/to|or directly the key&quot;</span>
</pre></div>
</div>
<section id="id1">
<h5>Summary<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h5>
<p><em>pro:</em></p>
<ul class="simple">
<li><p>implementations like JWT are proven in use</p></li>
<li><p>allows to authenticate and authorize remote clients</p></li>
<li><p>allows to store costom additional information in a token</p></li>
</ul>
<p><em>cons:</em></p>
<ul class="simple">
<li><p>elos protocol must be changed</p></li>
<li><p>needs rework of current connection handling in elos</p></li>
<li><p>overhead of token length in each elosd paket</p></li>
<li><p>needs additional infrastructure.</p>
<ul>
<li><p>identity service</p></li>
<li><p>How to revoke tokens</p></li>
<li><p>How to store keys securely</p></li>
</ul>
</li>
</ul>
</section>
</section>
</section>
<section id="normal-clients-current-status">
<h3>Normal Clients (current status)<a class="headerlink" href="#normal-clients-current-status" title="Link to this heading">¶</a></h3>
<p>Normal clients doesn’t need any authentication or authorization. All
connections of normal clients are treated as non-secure and hence need
filtering of black listed events.</p>
</section>
<section id="configurable-elements">
<h3>Configurable elements<a class="headerlink" href="#configurable-elements" title="Link to this heading">¶</a></h3>
<p>To manage privileged an normal clients two configuration items are necessary:</p>
<ul class="simple">
<li><p><em>for secure clients:</em> (Certs, Token) or a tuple of (UID, GID, ELF-Path)</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;trustedProcesses&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;&lt;client name | identifier&gt;&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;gid&quot;</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;executable&quot;</span><span class="p">:</span><span class="w"> </span><span class="nt">&quot;/bin/crinit&quot;</span>
<span class="w">    </span><span class="nt">&quot;cert&quot;</span><span class="p">:</span><span class="w"> </span><span class="nt">&quot;/etc/elos/client_certs/...&quot;</span>
<span class="w">    </span><span class="nt">&quot;token&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;yxzkjlsdj87238...&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><em>for normal clients:</em> a BlackList defined as RPN-Filter i.e. blacklist all as ‘Security’ classified events:</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;EventBlacklist&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;.event.classification 0x4 EQ&quot;</span>
</pre></div>
</div>
</section>
<section id="the-blacklist-filtering">
<h3>The blacklist filtering<a class="headerlink" href="#the-blacklist-filtering" title="Link to this heading">¶</a></h3>
<p>For the blacklist filtering approach there are to variants possible, when to
check for a privileged clients.</p>
<ol class="arabic simple">
<li><p>check on establishing of connection</p></li>
</ol>
<p>If the client connection is authorized, the blacklist check can be skipped. If
the client is not authorized (normal client) a black list check must be
performed on each incoming event. If the client is not authorized and the event
hits the blacklist, the event is dropped.</p>
<ol class="arabic simple" start="2">
<li><p>check on receive of blacklisted event</p></li>
</ol>
<p>Each event is checked if matches the blacklist and if the blacklist matches it
is checked if the client is privileged, otherwise the event is dropped.</p>
<p>The attempt of sending a classified event from a normal client will create a
new event tirggered by elos it self to broadcast the insident:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;date&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">42</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;appName&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;elosd&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;pid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1234</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;severity&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;hardwareid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;hardwareid&gt;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;classification&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">324</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;messageCode&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">8007</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The value <code class="docutils literal notranslate"><span class="pre">classification</span></code> value is a concatenation of the flags <code class="docutils literal notranslate"><span class="pre">elos|Security|IPC</span></code>.</p>
</section>
</section>
<section id="decision">
<h2>Decision:<a class="headerlink" href="#decision" title="Link to this heading">¶</a></h2>
<p>In both cases we have to match all incoming events from normal clients (not
secure) against the blacklist. So the first solution gives us a little
advantage in processing speed by skipping the blacklist check entirely for
privileged clients (secure).</p>
<p>Thus we choose option 1 to implement the blacklist check. For client
authentication approach <em>A</em> of privilieged clients is choosen.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/elos_blue.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">elos</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userManual.html">Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../src/demos/index.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build/Debug/doc/source_generated/api/index.html">public API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../src/index.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build/Debug/doc/source_generated/developer/api/index.html">Complete API Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">ADRs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#list-of-adrs">List of ADRs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../index.html">How we document</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test/index.html">Verification Strategy or how we test</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Architecture Design Records</a><ul>
      <li>Previous: <a href="elos_logging_frameworks.html" title="previous chapter">Architecture Design Record - Evaluation Of Logging Frameworks</a></li>
      <li>Next: <a href="event_authorization_blacklisting.html" title="next chapter">Architecture Design Record - Blacklist filtering of published events</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, wolfgang.gehrhardt@emlix.com.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/doc/Architecture_Design_Records/event_authorization.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>